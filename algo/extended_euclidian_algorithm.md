
# Обобщенный алгоритм Евклида

*w.r.t Knuth, vol 1, page 41 (rus)*

> Даны два целых положительных числа `m` и `n`. Требуется найти их наибольший делитель `d` и два целых числа `a` и `b`, таких, что `am + bn = d`

### Моя попытка

Известно, что `m = nq + r`

1. Если `r == 0`, то `d = n, a = 0, b = 1`

    `am + bn = 0*m + 1*n = n = d`
    
2. Иначе
    
    Решим аналогичную задачу для `n` и `r`. 
    
    Найдем такие `x` и `y`, что `xn + yr == d`.
    
    Вычислим `a` и `b`:
    
    ```bash
    ## On the one hand:
    am + bn == d
    a(nq + r) + bn == d
    ar + (b+aq)n == d
    
    ## On the other hand:
    xn + yr == d
    
    ## Then
    a = y
    b + aq = x
    
    ## or
    a = y
    b = x - aq
    ```    
    
<details>

<summary> Code </summary>

```python
def extended_gcd(m, n):
    q, r = divmod(m, n)
    if r == 0:
        return (0, 1, n)

    x, y, d = extended_gcd(n, r)
    return (y, x - y * q, d)
```
</details>
    
### Алгоритм из книги "Искусство программирования. Кнут. Том 1"

1. [Инициализация] Присвоить `a' <- b <- 1`, `a <- b' <- 0, c <- m, d <- n`
2. [Деление] Пусть `q` и `r` - частное и остаток от деления `c` на `d` соответственно.
3. [Остаток - нуль?] Если `r = 0`, то останавливаемся; `a`,`b`,`d` найдены
4. [Повторение цикла] Присвоить `c <- d`, `d <- r`, `t <- a', a' <- a, a <- t - qa`, `t <- b', b' <- b, b <- t - qb` и вернуться к шагу 2.

Как это работает:

Важно заметить, что на каждом шаге выполняются следующие равенства: 

$$ a'm + b'n = c $$ 
$$ am + bn = d $$

Используя их можно вывести формулы из 4 шага алгоритма:

*(Далее индекс означает номер итерации)*

`a0' * m + b0' * n = c0, a0 * m + b0 * n = d0`

`c0 = q0 * d0 + r0`


`c1 = d0, d1 = r0`


из `a1' * m + b1' * n = c1` и `c1 = d0` следует

`a1' * m + b1' * n = a0 * m + b0 * n`

а значит: `a1' = a0, b1' = b0` (`a' <- a` и `b' <- b` из алгоритма)


из `a1 * m + b1 * n = d1` и `d1 = r0` следует

`a1 * m + b1 * n = c0 - q0 * d0 = (a0' * m + b0' * n) - q0 * (a0 * m + b0 * n)`

или 

`a1 * m + b1 * n = (a0' - q0 * a0) * m + (b0' - q0 * b0) * n`

откуда

`a1 = a0' - q0 * a0` (`t <- a', a <- t - qa` из 4 шага алгоритма)

`b1 = b0' - q0 * b0` (`t <- b', b <- t - qb` из 4 шага алгоритма)


